# -*- coding: utf-8 -*-
"""
Created on Mon May 15 23:23:18 2023

@author: Eric
"""
#Reference
#https://www.pygame.org/docs/ref/music.html#pygame.mixer.music.load
#coding game python text


#this improts the random module
import pgzrun
from random import randint
from pgzero.builtins import Actor

#set the stage 
#define the size of the stage
WIDTH = 800
HEIGHT = 600
CENTER_X = WIDTH/2
CENTER_Y = HEIGHT/2

#contains list of the dance moves
move_list = []
display_list = []

#variables used to assign integer values needed in game
score1 = 0
score2 = 0 #score for second player
current_move = 0
count = 4 
dance_length = 4 

#flag variables to keep track of what's happening in game
say_dance = False
show_countdown = True
moves_complete = False
game_over = False
# 1 for first player and 2 for second
turn = 1
# to change turnse
moves_this_turn = 0

# Actors
#starting position of the danceer defined for each actor
dancer = Actor("dancer-start", (CENTER_X + 5, CENTER_Y - 40))
dancer2 = Actor("dancer2-start", (CENTER_X + 5, CENTER_Y - 40))
#dancer.pos = CENTER_X + 5, CENTER_Y - 40
#dancer2.pos=CENTER_X + 5, CENTER_Y - 40

up= Actor("up")
up.pos = CENTER_X, CENTER_Y + 110
right = Actor("right")
right.pos = CENTER_X + 60, CENTER_Y + 170
down = Actor("down")
down.pos = CENTER_X, CENTER_Y + 230
left = Actor("left")
left.pos = CENTER_X - 60, CENTER_Y + 170

def draw():
    global game_over, score1, score2, say_dance
    global count, show_countdown
    screen.clear()
    # adds a background in the game window
    screen.blit("stage", (0, 0))
    # runs if game isn't over
    if not game_over:
        if turn == 1:
            dancer.draw()
        else:
            dancer2.draw()
        #draws actor in current position
        up.draw()
        down.draw()
        right.draw()
        left.draw()
        #prints the socre in top left
    screen.draw.text("Score Player 1: " + str(score1), color="black",
                     topleft=(10, 10))
    screen.draw.text("Score Player 2: " + str(score2), color="black",
                     topleft=(10, 30))
    if say_dance:
        #draws the word Dance on screen
        screen.draw.text("Dance!", color="black",
                         topleft=(CENTER_X - 65, 150), fontsize=60)
    if show_countdown:
        #displays current value of count
        screen.draw.text(str(count), color="black",
                         topleft=(CENTER_X - 8, 150), fontsize=60)
    #runs if game over is true
    if game_over:
        screen.draw.text("GAME OVER!", color="black",
                         topleft=(CENTER_X - 130, 220), fontsize=60)

#sets the actors back to original position
def reset_dancer():
    global game_over, turn
    if not game_over:
        if turn == 1:
            dancer.image = "dancer-start"
        else:
            dancer2.image = "dancer2-start"
        up.image = "up"
        right.image = "right"
        down.image = "down"
        left.image = "left"
    return
#updates the actors to show a dance move
#tells dancer which move to perform next
def update_dancer(move):
    global game_over, turn
    if not game_over:
        if move == 0:
            up.image = "up-lit"
            if turn == 1:
                dancer.image = "dancer-up"
            else:
                dancer2.image = "dancer2-up"
            clock.schedule(reset_dancer, 0.5)
        elif move == 1:
            right.image = "right-lit"
            if turn == 1:
                dancer.image = "dancer-right"
            else:
               
                dancer2.image = "dancer2-right"
            clock.schedule(reset_dancer, 0.5)
        elif move == 2:
            down.image = "down-lit"
            if turn == 1:
                dancer.image = "dancer-down"
            else:
                dancer2.image = "dancer2-down"
            clock.schedule(reset_dancer, 0.5)
        else:
            left.image = "left-lit"
            if turn == 1:
                dancer.image = "dancer-left"
            else:
                dancer2.image = "dancer2-left"
            clock.schedule(reset_dancer, 0.5)
    return
#displays the latest sequence of moves generated by program
def display_moves():
    global move_list, display_list, dance_length
    global say_dance, show_countdown, current_move
    #checks if list of dance moves has something in it
    if display_list:
        #stores the first move in display_list in variable this_move
        this_move = display_list[0]
        display_list = display_list[1:]
        #removes first item from display_list so second item is in position 0
        if this_move == 0:
            #if value is 0 then it is passed onto function
            update_dancer(0)
            #schedules a call to function display_moves() in 1 second
            clock.schedule(display_moves, 1)
        elif this_move == 1:
            update_dancer(1)
            clock.schedule(display_moves, 1)
        elif this_move == 2:
            update_dancer(2)
            clock.schedule(display_moves, 1)
        else:
            update_dancer(3)
            clock.schedule(display_moves, 1)
    else:
        #if display_list is empty then this tells draw() to display "Dance!"
        say_dance = True
        #sets global variable show_countdown to false
        show_countdown = False
    return
#generates a list of dance moves
def generate_moves():
    global move_list, dance_length, count
    global show_countdown, say_dance
    count = 4
    move_list = []
    say_dance = False
    for move in range(0, dance_length):
        #assigns values 0,1,2, or 3 at random
        rand_move = randint(0, 3)
        #adds each new move to end of list of moves
        move_list.append(rand_move)
        display_list.append(rand_move)
    #displays value in count to create countdown
    show_countdown = True
    countdown()
    return
#displays the countdown before each sequence
def countdown():
    global count, game_over, show_countdown
    if count > 1:
        #updates value in count by subtracting
        count = count - 1
        #schedules another call in 1 second
        clock.schedule(countdown, 1)
    else:
        #removes countdown from screen if count is less than or equal to 1
        show_countdown = False
        display_moves()
    return
#goes to next move on list
def next_move():
    #current_move identifies which move your dealing with
    global dance_length, current_move, moves_complete
    #condition is True if there still some moves left
    if current_move < dance_length - 1:
        #moves current move onto next move
        current_move = current_move + 1
    #blocks run if there are no more moves
    else:
        moves_complete = True
    return
#makes program react
#each time an arrow key is pressed the update_dancer() makes dancer perform relevant move
def on_key_up(key):
    global score1, score2, game_over, move_list, current_move, turn, moves_this_turn
    if not game_over:
        #this increases the move count for the turn
        moves_this_turn += 1
        if key == keys.UP:
            update_dancer(0)
            if move_list[current_move] == 0:
                if turn == 1:
                    #blocks run if player presses the correct key
                    score1 = score1 + 1
                else:
                    score2 = score2 + 1
                next_move()
            else:
                game_over = True
        elif key == keys.RIGHT:
            update_dancer(1)
            if move_list[current_move] == 1:
                if turn == 1:
                    score1 = score1 + 1
                else:
                    score2 = score2 + 1
                next_move()
            else:
                game_over = True
        elif key == keys.DOWN:
            update_dancer(2)
            if move_list[current_move] == 2:
                if turn == 1:
                    score1 = score1 + 1
                else:
                    score2 = score2 + 1
                next_move()
            else:
                game_over = True
        elif key == keys.LEFT:
            update_dancer(3)
            if move_list[current_move] == 3:
                if turn == 1:
                    score1 = score1 + 1
                else:
                    score2 = score2 + 1
                next_move()
            else:
                game_over = True
        #This is to reset after making 4 moves per turn and to switch turns
        if moves_this_turn == 4: 
            moves_this_turn = 0  
            turn = 2 if turn == 1 else 1
#Generation test
generate_moves()
#plays audio file in music folder
music.play("educated")

#built in pygame function
def update():
    global game_over, current_move, moves_complete
    if not game_over:
        if moves_complete:
            generate_moves()
            moves_complete = False
            current_move = 0
    else:
        #stops playing when game over
        music.stop()
        clock.schedule_unique(reset_game, 3)

def reset_game():
    global game_over, score1, score2, current_move, moves_complete, turn
    game_over = False

pgzrun.go()